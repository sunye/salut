package org.atlanmod.salut.mdns;

import org.atlanmod.commons.log.Log;
import org.atlanmod.salut.io.ByteArrayReader;
import org.atlanmod.salut.io.ByteArrayWriter;
import org.atlanmod.salut.io.UnsignedShort;

import java.util.Objects;

public class Header {

    /**
     * Identifier: A 16-bit identification field generated by the device that creates the DNS query.
     * It is copied by the server into the response, so it can be used by that device to match that query to the
     * corresponding reply received from a DNS server.
     * This is used in a manner similar to how the Identifier field is used in many of the ICMP message types.
     */
    private final UnsignedShort id;

    /**
     * Flags and codes.
     */
    private final QRFlag flags;

    /**
     * Question Count: Specifies the number of questionRecordCount in the Question section of the message.
     */
    private final UnsignedShort questionRecordCount;

    /**
     * Answer AbstractRecord Count: Specifies the number of resource records in the Answer section of the message.
     */
    private final UnsignedShort answerRecordCount;

    /**
     * Authority AbstractRecord Count: Specifies the number of resource records in the Authority section of the message.
     */
    private final UnsignedShort authorityRecordCount;

    /**
     * Additional AbstractRecord Count: Specifies the number of resource records in the Additional section of the message.
     */
    private final UnsignedShort additionalRecordCount;

    /**
     * Creates a new m-dns header
     *
     * @param id
     * @param flags
     * @param questionRecordCount
     * @param answerRecordCount
     * @param authorityRecordCount
     * @param additionalRecordCount
     */
    private Header(UnsignedShort id, QRFlag flags, UnsignedShort questionRecordCount,
                   UnsignedShort answerRecordCount, UnsignedShort authorityRecordCount, UnsignedShort additionalRecordCount) {
        this.id = id;
        this.flags = flags;
        this.questionRecordCount = questionRecordCount;
        this.answerRecordCount = answerRecordCount;
        this.authorityRecordCount = authorityRecordCount;
        this.additionalRecordCount = additionalRecordCount;
    }

    /**
     * Converts the header's contents into a String
     *
     * @return String representing the header.
     */
    @Override
    public String toString() {
        return "Header{" +
                "id=" + id +
                ", flags=" + flags +
                ", questionRecordCount=" + questionRecordCount +
                ", answerRecordCount=" + answerRecordCount +
                ", authorityRecordCount=" + authorityRecordCount +
                ", additionalRecordCount=" + additionalRecordCount +
                '}';
    }

    @Override
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }
        if (other == null || getClass() != other.getClass()) {
            return false;
        }
        Header header = (Header) other;
        return Objects.equals(id, header.id) &&
                Objects.equals(flags, header.flags) &&
                Objects.equals(questionRecordCount, header.questionRecordCount) &&
                Objects.equals(answerRecordCount, header.answerRecordCount) &&
                Objects.equals(authorityRecordCount, header.authorityRecordCount) &&
                Objects.equals(additionalRecordCount, header.additionalRecordCount);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, flags, questionRecordCount, answerRecordCount, authorityRecordCount, additionalRecordCount);
    }

    public int id() {
        return id.intValue();
    }

    /**
     * The number of question records.
     *
     * @return int
     */
    public int questionRecordCount() {
        return questionRecordCount.intValue();
    }

    /**
     * The number of answer records.
     *
     * @return int
     */
    public int answerRecordCount() {
        return answerRecordCount.intValue();
    }

    /**
     * The number of authority records.
     *
     * @return int
     */
    public int authorityRecordCount() {
        return authorityRecordCount.intValue();
    }

    /**
     * The number of additional records.
     *
     * @return the count of additional records.
     */
    public int additionalRecordCount() {
        return additionalRecordCount.intValue();
    }

    public QRFlag flags() {
        return flags;
    }

    /**
     * Writes the contents of this header to a byte array buffer.
     *
     * @param buffer a byte array buffer where the header will be written.
     */
    public void writeOn(ByteArrayWriter buffer) {
        buffer.putUnsignedShort(id);
        buffer.putUnsignedShort(flags.toUnsignedShort());
        buffer.putUnsignedShort(questionRecordCount);
        buffer.putUnsignedShort(answerRecordCount);
        buffer.putUnsignedShort(authorityRecordCount);
        buffer.putUnsignedShort(additionalRecordCount);
    }

    /**
     * Creates a new header from a byte array buffer.
     *
     * @param buffer
     * @return a new Header instance
     */
    public static Header fromByteBuffer(ByteArrayReader buffer) {
        UnsignedShort id            = buffer.getUnsignedShort();
        QRFlag flags      = QRFlag.fromUnsignedShort(buffer.getUnsignedShort());
        UnsignedShort questions     = buffer.getUnsignedShort();
        UnsignedShort answers       = buffer.getUnsignedShort();
        UnsignedShort authorityRR   = buffer.getUnsignedShort();
        UnsignedShort additionalRR  = buffer.getUnsignedShort();

        Header newHeader = new Header(id, flags, questions, answers, authorityRR, additionalRR);

        Log.info("Parsed header: {0}", newHeader);
        return  newHeader;
    }
}
